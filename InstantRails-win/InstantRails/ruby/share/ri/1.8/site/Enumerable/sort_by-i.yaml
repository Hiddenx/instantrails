--- !ruby/object:RI::MethodDescription 
aliases: []
block_params: 
comment: 
  - !ruby/struct:SM::Flow::P 
    body: Sorts <em>enum</em> using a set of keys generated by mapping the values in <em>enum</em> through the given block.
  - !ruby/struct:SM::Flow::VERB 
    body: |2
         %w{ apple pear fig }.sort_by {|word| word.length}
                      #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]

  - !ruby/struct:SM::Flow::P 
    body: The current implementation of <tt>sort_by</tt> generates an array of tuples containing the original collection element and the mapped value. This makes <tt>sort_by</tt> fairly expensive when the keysets are simple
  - !ruby/struct:SM::Flow::VERB 
    body: |2
         require 'benchmark'
         include Benchmark

         a = (1..100000).map {rand(100000)}

         bm(10) do |b|
           b.report(&quot;Sort&quot;)    { a.sort }
           b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }
         end

  - !ruby/struct:SM::Flow::P 
    body: "<em>produces:</em>"
  - !ruby/struct:SM::Flow::VERB 
    body: |2
         user     system      total        real
         Sort        0.180000   0.000000   0.180000 (  0.175469)
         Sort by     1.980000   0.040000   2.020000 (  2.013586)

  - !ruby/struct:SM::Flow::P 
    body: "However, consider the case where comparing the keys is a non-trivial operation.
      The following code sorts some files on modification time using the basic
      <tt>sort</tt> method."
  - !ruby/struct:SM::Flow::VERB 
    body: |2
         files = Dir[&quot;*&quot;]
         sorted = files.sort {|a,b| File.new(a).mtime &lt;=&gt; File.new(b).mtime}
         sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]

  - !ruby/struct:SM::Flow::P 
    body: "This sort is inefficient: it generates two new <tt>File</tt> objects during
      every comparison. A slightly better technique is to use the <tt>Kernel#test</tt>
      method to generate the modification times directly."
  - !ruby/struct:SM::Flow::VERB 
    body: |2
         files = Dir[&quot;*&quot;]
         sorted = files.sort { |a,b|
           test(?M, a) &lt;=&gt; test(?M, b)
         }
         sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]

  - !ruby/struct:SM::Flow::P 
    body: "This still generates many unnecessary <tt>Time</tt> objects. A more efficient
      technique is to cache the sort keys (modification times in this case) before the
      sort. Perl users often call this approach a Schwartzian Transform, after Randal
      Schwartz. We construct a temporary array, where each element is an array
      containing our sort key along with the filename. We sort this array, and then
      extract the filename from the result."
  - !ruby/struct:SM::Flow::VERB 
    body: |2
         sorted = Dir[&quot;*&quot;].collect { |f|
            [test(?M, f), f]
         }.sort.collect { |f| f[1] }
         sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]

  - !ruby/struct:SM::Flow::P 
    body: This is exactly what <tt>sort_by</tt> does internally.
  - !ruby/struct:SM::Flow::VERB 
    body: |2
         sorted = Dir[&quot;*&quot;].sort_by {|f| test(?M, f)}
         sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]

full_name: Enumerable#sort_by
is_singleton: false
name: sort_by
params: "enum.sort_by {| obj | block }    => array

  "
visibility: public