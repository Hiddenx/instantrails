<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: GemPlugin::Manager</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">GemPlugin::Manager</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/gem_plugin_rb.html">
                lib/gem_plugin.rb
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                Object
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
This class is used by people who use gem plugins (but don&#8217;t
necessarily make them) to add plugins to their own systems. It provides a
way to load plugins, list them, and create them as needed.
</p>
<p>
It is a singleton so you use like this: GemPlugins::Manager.instance.load
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000068">config</a>&nbsp;&nbsp;
      <a href="#M000065">create</a>&nbsp;&nbsp;
      <a href="#M000063">load</a>&nbsp;&nbsp;
      <a href="#M000066">loaded?</a>&nbsp;&nbsp;
      <a href="#M000062">new</a>&nbsp;&nbsp;
      <a href="#M000064">register</a>&nbsp;&nbsp;
      <a href="#M000067">resource</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->
    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">
        <span class="include-name">Singleton</span>
      </div>
    </div>

    <div id="section">





    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">gems</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">plugins</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000062" class="method-detail">
        <a name="M000062"></a>

        <div class="method-heading">
          <a href="Manager.src/M000062.html" target="Code" class="method-signature"
            onclick="popupCode('Manager.src/M000062.html');return false;">
          <span class="method-name">new</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000068" class="method-detail">
        <a name="M000068"></a>

        <div class="method-heading">
          <a href="Manager.src/M000068.html" target="Code" class="method-signature"
            onclick="popupCode('Manager.src/M000068.html');return false;">
          <span class="method-name">config</span><span class="method-args">(gem_name, options={})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
While <a href="Manager.html#M000067">Manager.resource</a> will find
arbitrary resources, a special case is when you need to load a set of
configuration defaults. <a href="../GemPlugin.html">GemPlugin</a>
normalizes this to be if you have a file
&quot;resources/defaults.yaml&quot; then you&#8217;ll be able to load them
via <a href="Manager.html#M000068">Manager.config</a>.
</p>
<p>
How you use the method is you get the options the user wants set, pass them
to Manager.instance.config, and what you get back is a new Hash with the
user&#8217;s settings overriding the defaults.
</p>
<pre>
  opts = Manager.instance.config &quot;mygem&quot;, :age =&gt; 12, :max_load =&gt; .9
</pre>
<p>
In the above case, if defaults had {:age =&gt; 14} then it would be changed
to 12.
</p>
<p>
This loads the .yaml file on the fly every time, so doing it a whole lot is
very stupid. If you need to make frequent calls to this, call it once with
no options (Manager.instance.config) then use the returned defaults
directly from then on.
</p>
        </div>
      </div>

      <div id="method-M000065" class="method-detail">
        <a name="M000065"></a>

        <div class="method-heading">
          <a href="Manager.src/M000065.html" target="Code" class="method-signature"
            onclick="popupCode('Manager.src/M000065.html');return false;">
          <span class="method-name">create</span><span class="method-args">(name, options = {})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resolves the given name (should include /category/name) to find the plugin
class and create an instance. You can pass a second hash option that is
then given to the Plugin to configure it.
</p>
        </div>
      </div>

      <div id="method-M000063" class="method-detail">
        <a name="M000063"></a>

        <div class="method-heading">
          <a href="Manager.src/M000063.html" target="Code" class="method-signature"
            onclick="popupCode('Manager.src/M000063.html');return false;">
          <span class="method-name">load</span><span class="method-args">(needs = {})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Responsible for going through the list of available gems and loading any
plugins requested. It keeps track of what it&#8217;s loaded already and
won&#8217;t load them again.
</p>
<p>
It accepts one parameter which is a hash of gem depends that should include
or exclude a gem from being loaded. A gem must depend on gem_plugin to be
considered, but then each system has to add it&#8217;s own INCLUDE to make
sure that only plugins related to it are loaded.
</p>
<p>
An example again comes from Mongrel. In order to load all Mongrel plugins:
</p>
<pre>
 GemPlugin::Manager.instance.load &quot;mongrel&quot; =&gt; GemPlugin::INCLUDE
</pre>
<p>
Which will load all plugins that depend on mongrel AND gem_plugin. Now, one
extra thing we do is we delay loading Rails Mongrel plugins until after
rails is configured. Do do this the mongrel_rails script has:
</p>
<p>
GemPlugin::Manager.instance.load &quot;mongrel&quot; =&gt;
GemPlugin::INCLUDE, &quot;rails&quot; =&gt; GemPlugin::EXCLUDE The only
thing to remember is that this is saying &quot;include a plugin if it
depends on gem_plugin, mongrel, but NOT rails&quot;. If a plugin also
depends on other stuff then it&#8217;s loaded just fine. Only gem_plugin,
mongrel, and rails are ever used to determine if it should be included.
</p>
<p>
NOTE: Currently RubyGems will run autorequire on gems that get required AND
on their dependencies. This really messes with people running edge rails
since activerecord or other stuff gets loaded for just touching a gem
plugin. To prevent this load requires the full path to the
&quot;init.rb&quot; file, which avoids the RubyGems autorequire magic.
</p>
        </div>
      </div>

      <div id="method-M000066" class="method-detail">
        <a name="M000066"></a>

        <div class="method-heading">
          <a href="Manager.src/M000066.html" target="Code" class="method-signature"
            onclick="popupCode('Manager.src/M000066.html');return false;">
          <span class="method-name">loaded?</span><span class="method-args">(gem_name)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Simply says whether the given gem has been loaded yet or not.
</p>
        </div>
      </div>

      <div id="method-M000064" class="method-detail">
        <a name="M000064"></a>

        <div class="method-heading">
          <a href="Manager.src/M000064.html" target="Code" class="method-signature"
            onclick="popupCode('Manager.src/M000064.html');return false;">
          <span class="method-name">register</span><span class="method-args">(category, name, klass)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Not necessary for you to call directly, but this is how <a
href="Base.html#M000059">GemPlugin::Base.inherited</a> actually adds a
plugin to a category.
</p>
        </div>
      </div>

      <div id="method-M000067" class="method-detail">
        <a name="M000067"></a>

        <div class="method-heading">
          <a href="Manager.src/M000067.html" target="Code" class="method-signature"
            onclick="popupCode('Manager.src/M000067.html');return false;">
          <span class="method-name">resource</span><span class="method-args">(gem_name, path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
GemPlugins can have a &#8216;resources&#8217; directory which is packaged
with them and can hold any data resources the plugin may need. The main
problem is that it&#8217;s difficult to figure out where these resources
are actually located on the file system. The resource method tries to
locate the real path for a given resource path.
</p>
<p>
Let&#8217;s say you have a &#8216;resources/stylesheets/default.css&#8217;
file in your gem distribution, then finding where this file really is
involves:
</p>
<pre>
  Manager.instance.resource(&quot;mygem&quot;, &quot;/stylesheets/default.css&quot;)
</pre>
<p>
You either get back the full path to the resource or you get a nil if it
doesn&#8217;t exist.
</p>
<p>
If you request a path for a <a href="../GemPlugin.html">GemPlugin</a> that
hasn&#8217;t been loaded yet then it will throw an <a
href="PluginNotLoaded.html">PluginNotLoaded</a> exception. The gem may be
present on your system in this case, but you just haven&#8217;t loaded it
with Manager.instance.load properly.
</p>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>