<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: ActiveRecord::Migration</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">ActiveRecord::Migration</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/active_record/migration_rb.html">
                lib/active_record/migration.rb
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                Object
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
Migrations can manage the evolution of a schema used by several physical
databases. It&#8217;s a solution to the common problem of adding a field to
make a new feature work in your local database, but being unsure of how to
push that change to other developers and to the production server. With
migrations, you can describe the transformations in self-contained classes
that can be checked into version control systems and executed against
another database that might be one, two, or five versions behind.
</p>
<p>
Example of a simple migration:
</p>
<pre>
  class AddSsl &lt; ActiveRecord::Migration
    def self.up
      add_column :accounts, :ssl_enabled, :boolean, :default =&gt; 1
    end

    def self.down
      remove_column :accounts, :ssl_enabled
    end
  end
</pre>
<p>
This migration will add a boolean flag to the accounts table and remove it
again, if you&#8217;re backing out of the migration. It shows how all
migrations have two class methods <tt>up</tt> and <tt>down</tt> that
describes the transformations required to implement or remove the
migration. These methods can consist of both the migration specific
methods, like add_column and remove_column, but may also contain regular
Ruby code for generating data needed for the transformations.
</p>
<p>
Example of a more complex migration that also needs to initialize data:
</p>
<pre>
  class AddSystemSettings &lt; ActiveRecord::Migration
    def self.up
      create_table :system_settings do |t|
        t.column :name,     :string
        t.column :label,    :string
        t.column :value,    :text
        t.column :type,     :string
        t.column :position, :integer
      end

      SystemSetting.create :name =&gt; &quot;notice&quot;, :label =&gt; &quot;Use notice?&quot;, :value =&gt; 1
    end

    def self.down
      drop_table :system_settings
    end
  end
</pre>
<p>
This migration first adds the system_settings table, then creates the very
first row in it using the Active Record model that relies on the table. It
also uses the more advanced create_table syntax where you can specify a
complete table schema in one block call.
</p>
<h2>Available transformations</h2>
<ul>
<li><tt>create_table(name, options)</tt> Creates a table called <tt>name</tt>
and makes the table object available to a block that can then add columns
to it, following the same format as add_column. See example above. The
options hash is for fragments like &quot;DEFAULT CHARSET=UTF-8&quot; that
are appended to the create table definition.

</li>
<li><tt>drop_table(name)</tt>: Drops the table called <tt>name</tt>.

</li>
<li><tt>add_column(table_name, column_name, type, options)</tt>: Adds a new
column to the table called <tt>table_name</tt> named <tt>column_name</tt>
specified to be one of the following types: :string, :text, :integer,
:float, :datetime, :timestamp, :time, :date, :binary, :boolean. A default
value can be specified by passing an <tt>options</tt> hash like { :default
=&gt; 11 }.

</li>
<li><tt>rename_column(table_name, column_name, new_column_name)</tt>: Renames a
column but keeps the type and content.

</li>
<li><tt>change_column(table_name, column_name, type, options)</tt>: Changes the
column to a different type using the same parameters as add_column.

</li>
<li><tt>remove_column(table_name, column_name)</tt>: Removes the column named
<tt>column_name</tt> from the table called <tt>table_name</tt>.

</li>
<li><tt>add_index(table_name, column_name, index_type)</tt>: Add a new index
with the name of the column on the column. Specify an optional index_type
(e.g. UNIQUE).

</li>
<li><tt>remove_index(table_name, column_name)</tt>: Remove the index called the
same as the column.

</li>
</ul>
<h2>Irreversible transformations</h2>
<p>
Some transformations are destructive in a manner that cannot be reversed.
Migrations of that kind should raise an <tt>IrreversibleMigration</tt>
exception in their <tt>down</tt> method.
</p>
<h2>Running migrations from within Rails</h2>
<p>
The Rails package has support for migrations with the <tt>script/generate
migration my_new_migration</tt> command and with the <tt>rake migrate</tt>
command that&#8217;ll run all the pending migrations. It&#8216;ll even
create the needed schema_info table automatically if it&#8217;s missing.
</p>
<h2>Database support</h2>
<p>
Migrations are currently only supported in MySQL and PostgreSQL.
</p>
<h2>More examples</h2>
<p>
Not all migrations change the schema. Some just fix the data:
</p>
<pre>
  class RemoveEmptyTags &lt; ActiveRecord::Migration
    def self.up
      Tag.find(:all).each { |tag| tag.destroy if tag.pages.empty? }
    end

    def self.down
      # not much we can do to restore deleted data
      raise IrreversibleMigration
    end
  end
</pre>
<p>
Others remove columns when they migrate up instead of down:
</p>
<pre>
  class RemoveUnnecessaryItemAttributes &lt; ActiveRecord::Migration
    def self.up
      remove_column :items, :incomplete_items_count
      remove_column :items, :completed_items_count
    end

    def self.down
      add_column :items, :incomplete_items_count
      add_column :items, :completed_items_count
    end
  end
</pre>
<p>
And sometimes you need to do something in SQL not abstracted directly by
migrations:
</p>
<pre>
  class MakeJoinUnique &lt; ActiveRecord::Migration
    def self.up
      execute &quot;ALTER TABLE `pages_linked_pages` ADD UNIQUE `page_id_linked_page_id` (`page_id`,`linked_page_id`)&quot;
    end

    def self.down
      execute &quot;ALTER TABLE `pages_linked_pages` DROP INDEX `page_id_linked_page_id`&quot;
    end
  end
</pre>
<h2>Using the class after changing table</h2>
<p>
Sometimes you&#8217;ll want to add a column in a migration and populate it
immediately after. In that case, you&#8217;ll need to make a call to <a
href="Base.html#M000530">Base#reset_column_information</a> in order to
ensure that the class has the latest column data from after the new column
was added. Example:
</p>
<pre>
  class MakeJoinUnique &lt; ActiveRecord::Migration
    def self.up
      add_column :people, :salary, :integer
      Person.find(:all).each do |p|
        p.salary = SalaryCalculator.compute(p)
      end
    end
  end
</pre>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000490">down</a>&nbsp;&nbsp;
      <a href="#M000489">up</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000490" class="method-detail">
        <a name="M000490"></a>

        <div class="method-heading">
          <a href="Migration.src/M000490.html" target="Code" class="method-signature"
            onclick="popupCode('Migration.src/M000490.html');return false;">
          <span class="method-name">down</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000489" class="method-detail">
        <a name="M000489"></a>

        <div class="method-heading">
          <a href="Migration.src/M000489.html" target="Code" class="method-signature"
            onclick="popupCode('Migration.src/M000489.html');return false;">
          <span class="method-name">up</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>