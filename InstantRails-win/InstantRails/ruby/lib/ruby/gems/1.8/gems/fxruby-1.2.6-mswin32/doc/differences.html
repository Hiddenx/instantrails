<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Appendix&nbsp;C.&nbsp;Differences between FOX and FXRuby</title><meta name="generator" content="DocBook XSL Stylesheets V1.61.2"><link rel="home" href="book.html" title="Developing Graphical User Interfaces with FXRuby"><link rel="up" href="pt02.html" title="Part&nbsp;II.&nbsp;Appendices"><link rel="previous" href="scintilla.html" title="Appendix&nbsp;B.&nbsp;Using Scintilla with FXRuby"><link rel="next" href="library.html" title="Appendix&nbsp;D.&nbsp;The FXRuby Standard Library"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Appendix&nbsp;C.&nbsp;Differences between FOX and FXRuby</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="scintilla.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Appendices</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="library.html">Next</a></td></tr></table><hr></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="differences"></a>Appendix&nbsp;C.&nbsp;Differences between FOX and FXRuby</h2></div></div><div></div></div><p>The FXRuby API follows the FOX API very closely and for the most part, you should be able to use the standard FOX class documentation as a reference. In some cases, however, fundamental differences between Ruby and C++ necessitated slight changes in the API. For some other cases, FOX classes were enhanced to take advantage of Ruby language features (such as iterators). The purpose of this chapter is to identify some of the differences between the C++ and Ruby interfaces to FOX.</p><p>One difference that should be easy to cope with is the substitution of Ruby Strings for FXStrings. Any function that would normally expect an <span class="type">FXString</span> input argument insteads takes a Ruby String. Similarly, functions that would return an <span class="type">FXString</span> will instead return a Ruby string. For functions that would normally accept a <tt class="constant">NULL</tt> or empty string argument, just pass <tt class="constant">nil</tt> or an empty string ("").</p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3320"></a>Functions that expect arrays of objects</h2></div></div><div></div></div><p>One common pattern in FOX member function argument lists is to expect a pointer to an array of values, followed by an integer indicating the number of values in the array. This of course isn't necessary in Ruby, where <tt class="classname">Array</tt> objects "know" their lengths. As a result, functions such as <tt class="methodname">FXWindow::acquireClipboard()</tt>, whose C++ declaration looks like this:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">FXbool acquireClipboard(const FXDragType *types, FXuint numTypes);</pre></td></tr></table><p>are called from Ruby code by passing in a single <tt class="classname">Array</tt> argument, e.g.</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">myWindow.acquireClipboard(typesArray)</pre></td></tr></table></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3340"></a>Functions that return values by reference</h2></div></div><div></div></div><p>Many FOX methods take advantage of the C++ language feature of returning values by reference. For example, the <tt class="methodname">getCursorPos()</tt> member function for class <tt class="classname">FXWindow</tt> has the declaration:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">FXint getCursorPos(FXint&amp; x, FXint&amp; y, FXint&amp; buttons) const;</pre></td></tr></table><p>which indicates that the function takes references to three integers (x, y and buttons). To call this function from a C++ program, you'd write code like this:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">FXint x, y;
FXuint buttons;

if (window-&gt;getCursorPosition(x, y, buttons))
  fprintf(stderr, "Current position is (%d, %d)\n", x, y);</pre></td></tr></table><p>Since this idiom doesn't translate well to Ruby, some functions' interfaces have been slightly modified. For example, the FXRuby implementation of <tt class="methodname">getCursorPos()</tt> returns the three values as an <tt class="classname">Array</tt>, e.g.:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">x, y, buttons = aWindow.getCursorPos()</pre></td></tr></table><p>The following table shows how these kinds of functions are implemented in FXRuby:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Instance Method</th><th align="center">Return Value</th></tr></thead><tbody><tr><td><tt class="methodname">FXDial#range</tt></td><td>Returns a <tt class="classname">Range</tt> instance.</td></tr><tr><td><tt class="methodname">FXDial#range=(aRange)</tt></td><td>Accepts a <tt class="classname">Range</tt> instance as its input.</td></tr><tr><td><tt class="methodname">FXFontDialog#fontSelection</tt></td><td>Returns the <tt class="classname">FXFontDesc</tt> instance</td></tr><tr><td><tt class="methodname">FXFontSelector#fontSelection</tt></td><td>Returns the <tt class="classname">FXFontDesc</tt> instance</td></tr><tr><td><tt class="methodname">FXGLObject#bounds(range)</tt></td><td>Takes an <tt class="classname">FXRange</tt> instance as its input and returns a (possibly modified) <tt class="classname">FXRange</tt> instance.</td></tr><tr><td><tt class="methodname">FXGLViewer#eyeToScreen(eye)</tt></td><td>Takes an array of eye coordinates (floats) as its input and returns the screen point coordinate as an array of integers [sx, sy]</td></tr><tr><td><tt class="methodname">FXGLViewer#getBoreVector(sx, sy)</tt></td><td>Returns the endpoint and direction vector as an array of arrays [point, dir]</td></tr><tr><td><tt class="methodname">FXGLViewer#light</tt></td><td>Returns a <tt class="classname">FXLight</tt> instance</td></tr><tr><td><tt class="methodname">FXGLViewer#viewport</tt></td><td>Returns an <tt class="classname">FXViewport</tt> instance.</td></tr><tr><td><tt class="methodname">FXPrinterDialog#printer</tt></td><td>Returns the <tt class="classname">FXPrinter</tt> instance</td></tr><tr><td><tt class="methodname">FXScrollArea#position</tt></td><td>Returns the position as an array of integers [x, y]</td></tr><tr><td><tt class="methodname">FXSlider#range</tt></td><td>Returns a <tt class="classname">Range</tt> instance.</td></tr><tr><td><tt class="methodname">FXSlider#range=(aRange)</tt></td><td>Accepts a <tt class="classname">Range</tt> instance as its input.</td></tr><tr><td><tt class="methodname">FXSpinner#range</tt></td><td>Returns a <tt class="classname">Range</tt> instance.</td></tr><tr><td><tt class="methodname">FXSpinner#range=(aRange)</tt></td><td>Accepts a <tt class="classname">Range</tt> instance as its input.</td></tr><tr><td><tt class="methodname">FXText#appendText(text, notify=false)</tt></td><td>Append text to the end of the buffer.</td></tr><tr><td><tt class="methodname">FXText#appendStyledText(text, style=0, notify=false)</tt></td><td>Append styled text to the end of the buffer.</td></tr><tr><td><tt class="methodname">FXText#extractText(pos, n)</tt></td><td>Extracts <span class="emphasis"><em>n</em></span> characters from the buffer beginning at position <span class="emphasis"><em>pos</em></span> and returns the result as a String.</td></tr><tr><td><tt class="methodname">FXText#extractStyle(pos, n)</tt></td><td>Extracts <span class="emphasis"><em>n</em></span> style characters from the buffer beginning at position <span class="emphasis"><em>pos</em></span> and returns the result as a String.</td></tr><tr><td><tt class="methodname">FXText#insertText(pos, text, notify=false)</tt></td><td>Insert <span class="emphasis"><em>text</em></span> at position <span class="emphasis"><em>pos</em></span> in the buffer.</td></tr><tr><td><tt class="methodname">FXText#insertStyledText(pos, text, style=0, notify=false)</tt></td><td>Insert <span class="emphasis"><em>text</em></span> at position <span class="emphasis"><em>pos</em></span> in the buffer.</td></tr><tr><td><tt class="methodname">FXText#replaceText(pos, m, text, notify=false)</tt></td><td>Replace <span class="emphasis"><em>m</em></span> characters at <span class="emphasis"><em>pos</em></span> by <span class="emphasis"><em>text</em></span>.</td></tr><tr><td><tt class="methodname">FXText#replaceStyledText(pos, m, text, style=0, notify=false)</tt></td><td>Replace <span class="emphasis"><em>m</em></span> characters at <span class="emphasis"><em>pos</em></span> by <span class="emphasis"><em>text</em></span>.</td></tr><tr><td><tt class="methodname">FXText#setDelimiters(delimiters)</tt></td><td>Change delimiters of words (<span class="emphasis"><em>delimiters</em></span> is a string).</td></tr><tr><td><tt class="methodname">FXText#getDelimiters()</tt></td><td>Return word delimiters as a string.</td></tr><tr><td><tt class="methodname">FXWindow#cursorPosition</tt></td><td>Returns an array of integers [x, y, buttons]</td></tr><tr><td><tt class="methodname">FXWindow#translateCoordinatesFrom(window, x, y)</tt></td><td>Returns the translated coordinates as an array [x, y]</td></tr><tr><td><tt class="methodname">FXWindow#translateCoordinatesTo(window, x, y)</tt></td><td>Returns the translated coordinates as an array [x, y]</td></tr></tbody></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3630"></a>Iterators</h2></div></div><div></div></div><p>Several classes have been extended with an <tt class="methodname">each</tt> method to provide Ruby-style iterators. These classes include <tt class="classname">FXComboBox</tt>, <tt class="classname">FXGLGroup</tt>, <tt class="classname">FXHeader</tt>, <tt class="classname">FXIconList</tt>, <tt class="classname">FXList</tt>, <tt class="classname">FXListBox</tt>, <tt class="classname">FXTreeItem</tt>, <tt class="classname">FXTreeList</tt> and <tt class="classname">FXTreeListBox</tt>. These classes also mix-in Ruby's <tt class="classname">Enumerable</tt> module so that you can take full advantage of the iterators.</p><p>The block parameters passed to your code block vary depending on the class. For example, iterating over an <tt class="classname">FXList</tt> instance yields <tt class="classname">FXListItem</tt> parameters:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">aList.each { |aListItem|
    puts "text for this item = #{aListItem.getText()}"
}</pre></td></tr></table><p>whereas iterating over an <tt class="classname">FXComboBox</tt> instance yields two parameters, the item text (a string) and the item data:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">aComboBox.each { |itemText, itemData|
    puts "text for this item = #{itemText}"
}</pre></td></tr></table><p>The following table shows the block parameters for each of these classes' iterators:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Class</th><th align="center">Block Parameters</th></tr></thead><tbody><tr><td><tt class="classname">FXComboBox</tt></td><td>the item text (a string) and user data</td></tr><tr><td><tt class="classname">FXGLGroup</tt></td><td>an <tt class="classname">FXGLObject</tt> instance</td></tr><tr><td><tt class="classname">FXHeader</tt></td><td>an <tt class="classname">FXHeaderItem</tt> instance</td></tr><tr><td><tt class="classname">FXIconList</tt></td><td>an <tt class="classname">FXIconItem</tt> instance</td></tr><tr><td><tt class="classname">FXList</tt></td><td>an <tt class="classname">FXListItem</tt> instance</td></tr><tr><td><tt class="classname">FXListBox</tt></td><td>the item text (a string), icon (an <tt class="classname">FXIcon</tt> instance) and user data</td></tr><tr><td><tt class="classname">FXTreeItem</tt></td><td>an <tt class="classname">FXTreeItem</tt> instance</td></tr><tr><td><tt class="classname">FXTreeList</tt></td><td>an <tt class="classname">FXTreeItem</tt> instance</td></tr><tr><td><tt class="classname">FXTreeListBox</tt></td><td>an <tt class="classname">FXTreeItem</tt> instance</td></tr></tbody></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3774"></a>Attribute Accessors</h2></div></div><div></div></div><p>FOX strictly handles access to all object attributes through member functions, e.g. <tt class="methodname">setBackgroundColor</tt> and <tt class="methodname">getBackgroundColor</tt> or <tt class="methodname">setText</tt> and <tt class="methodname">getText</tt>. FXRuby exposes all of these functions but also provides aliases that look more like regular Ruby attribute accessors. The names for these accessors are based on the FOX method names; for example, <tt class="methodname">setBackgroundColor</tt> and <tt class="methodname">getBackgroundColor</tt> are aliased to <tt class="methodname">backgroundColor=</tt> and <tt class="methodname">backgroundColor</tt>, respectively.</p><p>In many cases these aliases allow you to write more compact and legible code. For example, consider this code snippet:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">aLabel.setText(aLabel.getText() + " (modified)")</pre></td></tr></table><p>Now consider a different code snippet, using the aliased accessor method names:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">aLabel.text += " (modified)"</pre></td></tr></table><p>While these two are functionally equivalent, the latter is a bit easier to read and understand at first glance.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3813"></a>Message Passing</h2></div></div><div></div></div><p>FOX message maps are implemented as static C++ class members. With FXRuby, you just associate messages with message handlers in the class <tt class="methodname">initialize</tt> method using the <tt class="methodname">FXMAPFUNC()</tt>, <tt class="methodname">FXMAPTYPE()</tt>, <tt class="methodname">FXMAPTYPES()</tt> or <tt class="methodname">FXMAPFUNCS()</tt> methods. See almost any of the example programs for examples of how this is done.</p><p>As in C++ FOX, the last argument passed to your message handler functions contains message-specific data. For instance, all <tt class="constant">SEL_PAINT</tt> messages pass an <tt class="classname">FXEvent</tt> object through this argument to give you some information about the size of the exposed rectangle. On the other hand, a <tt class="constant">SEL_COMMAND</tt> message from an <tt class="classname">FXHeader</tt> object passes the index of the selected header item through this argument. Instead of guessing what's in this last argument, your best bet is to instead invoke a member function on the sending object to find out what you need, instead of relying on the data passed through this pointer. For example, if you get a <tt class="constant">SEL_COMMAND</tt> message from an <tt class="classname">FXColorWell</tt> object, the data passed through that last argument is supposed to be the new RGB color value. Instead of trying to interpret the argument's contents, just turn around and call the color well's <tt class="methodname">getRGBA()</tt> member function to retrieve its color. Similarly, if you get a <tt class="constant">SEL_COMMAND</tt> message from a tree list, call its <tt class="methodname">getCurrentItem()</tt> method to find out which item was selected.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3862"></a>Catching Operating System Signals</h2></div></div><div></div></div><p>The <tt class="methodname">FXApp#addSignal</tt> and <tt class="methodname">FXApp#removeSignal</tt> methods have been enhanced to accept either a string or integer as their first argument. If it's a string (e.g. "SIGINT" or just "INT") the code will determine the corresponding signal number for you (similar to the standard Ruby library's <tt class="methodname">Process.kill</tt> module method). For examples of how to use this, see the <tt class="filename">datatarget.rb</tt> or <tt class="filename">imageviewer.rb</tt> example programs.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3882"></a>Support for Multithreaded Applications</h2></div></div><div></div></div><p>There is some support for multithreaded FXRuby applications, but it's not wonderful. The current implementation does what is also done in Ruby/GTK; it turns over some idle processing time to the Ruby thread scheduler to let other threads do their thing. As I learn more about Ruby's threading implementation I may try something different, but this seems to work OK for now. For a simple example, see the <tt class="filename">groupbox.rb</tt> example program, in which the clock label that appears in the lower right-hand corner is continuously updated (by a separate thread).</p><p>If you suspect that FXRuby's threads support is interfering with your application's performance, you may want to try tweaking the amount of time that the main application thread "sleeps" during idle processing; do this by setting the <tt class="classname">FXApp</tt> object's <i class="structfield"><tt>sleepTime</tt></i> attribute. The default value for <i class="structfield"><tt>FXApp#sleepTime</tt></i> is 100 milliseconds. You can also disable the threads support completely by calling <tt class="methodname">FXApp#threadsEnabled=false</tt> (and subsequently re-enable it with <tt class="methodname">FXApp#threadsEnabled=true</tt>).</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3907"></a>Debugging Tricks</h2></div></div><div></div></div><p>As a debugging tool, you can optionally catch exceptions raised in message handlers. To turn on this feature, call the <tt class="methodname">setIgnoreExceptions(true)</tt> module method. When this is enabled, any exceptions raised in message handler functions will cause a standard stack trace to be dumped to the standard output, but then your application will, for better or worse, proceed normally. Thanks to Ted Meng for this suggestion.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="scintilla.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="library.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Appendix&nbsp;B.&nbsp;Using Scintilla with FXRuby&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="book.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Appendix&nbsp;D.&nbsp;The FXRuby Standard Library</td></tr></table></div></body></html>