#!/usr/bin/env ruby
require 'drb'
begin
    require 'rubygems'
rescue
    # ignored so people don't *have* to have rubygems
end

require 'scgi'
require 'cmdparse'
require 'yaml'
require 'highline'


UI = HighLine.new

def password
    UI.ask("Password: ")
end

def print_status(s)
    times = s[:systimes]
        
    puts <<-END
#{UI.color("Status as of #{s[:time]}:",:green,:bold)}
PID: #{s[:pid]}\tStarted: #{s[:started]}\tEnvironment: #{s[:env]}
Connected Requests: #{s[:conns]}
Conns/Second: #{s[:throttle] || "Not Set"}
Total Conns: #{s[:total_conns]}
Max Simultaneous Conns: #{s[:max_conns]}
Shutdown Started: #{s[:shutdown]}
Processing Time:  #{times.utime} #{times.stime} #{times.cutime} #{times.cstime}
Current Settings:
#{s[:settings].to_yaml.gsub(/:([a-z])/, '   \1')}
END
end

def make_command(parent, name, desc, options=[])
    cmd = CmdParse::Command.new(name, false )
    cmd.short_desc = desc
    settings = {}
    cmd.options = CmdParse::OptionParserWrapper.new do |opt|
        options.each do |short, long, info, symbol|
            opt.on(short, long, info) {|val| settings[symbol] = val}
        end
    end
    cmd.set_execution_block do |args|
        #begin
            yield(settings, args)
        #rescue Object
        #    STDERR.puts "ERROR: Failed to run command: #$!"
        #end
    end
    parent.add_command(cmd)
end

cmd = CmdParse::CommandParser.new( true )
cmd.program_name = "scgi_ctrl"
cmd.program_version = [0, 4, 3]
cmd.options = CmdParse::OptionParserWrapper.new do |opt|
    opt.separator "Global options:"
    opt.on("-u", "--control-url URL", 'DRuby URL to run control on (same as SCGI -1000)') {|val| $control_url = val}
    opt.on('-c','--config PATH', 'Config file to use (#{SCGI::DEFAULT_CONFIG})') {|val| $config_path = val}
end

cmd.add_command( CmdParse::HelpCommand.new )
cmd.add_command( CmdParse::VersionCommand.new )

make_command(cmd, 'config', "Configure the SCGI server", 
[['-e','--env STRING','Rails environment', :env],
['-h','--host STRING', 'IP address to bind as server', :host],
['-p','--port NUMBER', 'Port to bind to (starts at 9999)', :port],
['-l','--log-file PATH', 'Use a different log from from log/scgi.log', :logfile],
['-t','--throttle NUMBER', 'Max conn/second to allow.', :throttle],
['-m','--max-conns NUMBER', 'Max simultaneous connections before the busy message', :maxconns],
['-S','--disable-signals', 'Turn off POSIX signals leaving only network control', :disable_signals],
['-D','--disable-net', 'Turn off network control leaving only POSIX signals', :disable_drb],
['-P','--moron-mode PASSWORD', 'You are an idiot and you want your password on the command line', :password],
['-M','--merge', 'Merge new settings with previous rather than defaults', :merge]]) do |settings, args|
    settings[:password] = settings[:password] || UI.ask("What password do you want? ")
    conf = SCGI::Configuration.new(settings)
    conf.configure
end

make_command(cmd, 'start', "Start the application",
[['-r','--run-path PATH', 'Change to this directory before trying to start', :run_path]]) do |settings, args|
    cmd = File.dirname(__FILE__) + "/scgi_service"
    kicker = SCGI::Kicker.new($config_path, settings[:run_path])
    pid = kicker.start(cmd)
end

make_command(cmd, 'reconfig', "Reconfigure the SCGI servers with a new config") do |settings, args|
    client = SCGI::ControlClient.new(settings, $config_path, $control_url, password)
    client.reconfigure
end

make_command(cmd, 'status', "Get status") do |settings, args|
    client = SCGI::ControlClient.new(settings, $config_path, $control_url, password)
    print_status(client.status)
end

make_command(cmd, 'stop', "Stop the application",
[['-f','--force', 'Forced shutdown rather than graceful (default graceful)', :force]]) do |settings, args|
    client = SCGI::ControlClient.new(settings, $config_path, $control_url, password)
    client.stop
end

make_command(cmd, 'restart', "Restart the application",
[['-f','--force', 'Forced shutdown rather than graceful (default graceful)', :force]]) do |settings, args|
    client = SCGI::ControlClient.new(settings, $config_path, $control_url, password)
    client.restart
end

make_command(cmd, 'monitor', "Monitor the application") do |settings, args|
    client = SCGI::ControlClient.new(settings, $config_path, $control_url, password)

    while true
        puts "\e[2J"
        print_status(client.status)
        sleep 3
    end
end

cmd.parse
