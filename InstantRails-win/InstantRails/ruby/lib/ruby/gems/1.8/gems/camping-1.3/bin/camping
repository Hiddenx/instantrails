#!/usr/bin/env ruby

# this line prevents other db adapters from being loaded (oci8 was
# causing some pain.)
RAILS_CONNECTION_ADAPTERS = %w[sqlite]

require 'stringio'
require 'webrick/httpserver'
require 'camping'

(puts <<USAGE; exit) if ARGV.length == 0
#{File.basename($0)}, the microframework ON-button for ruby #{RUBY_VERSION} (#{RUBY_RELEASE_DATE}) [#{RUBY_PLATFORM}]
Usage: #{File.basename($0)} your.camping.rb [your.camping.db]
USAGE

script, db = ARGV[0..-1]

unless db
    homes = []
    homes << File.join( ENV['HOME'], '.camping.db' ) if ENV['HOME']
    homes << File.join( ENV['APPDATA'], 'Camping.db' ) if ENV['APPDATA']
    homes.each do |db|
        break if File.exists?( db )
    end
end

Camping::Models::Base.establish_connection :adapter => 'sqlite3', :database => db

# Load the script, locate the module
def camp_load(script, klass = nil)
    Object.instance_eval { remove_const klass.name } if klass
    mtime = File.mtime(script)
    load script
    klass = Object.const_get(Object.constants.grep(/^#{File.basename(script)[/^(\w+)/,1]}$/i)[0]) rescue nil
    klass ||= Camping
    klass.create if klass.respond_to? :create
    [klass, mtime]
end

# Mount the root
klass, mtime = camp_load( script )
s = WEBrick::HTTPServer.new(:BindAddress => '0.0.0.0', :Port => 3301)
s.mount_proc("/") do |req, resp|
    newtime = File.mtime( script )
    if newtime > mtime
        klass, mtime = camp_load( script, klass )
    end
    controller = klass.run((req.body and StringIO.new(req.body)), req.meta_vars)
    resp.status = controller.status
    controller.headers.each do |k, v|
        [*v].each do |vi|
            resp[k] = vi
        end
    end
    resp.body = controller.body
    nil
end

# Server up
trap(:INT) do
    s.shutdown
end
s.start
