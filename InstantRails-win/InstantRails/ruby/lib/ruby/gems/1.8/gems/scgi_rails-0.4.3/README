= SCGI Rails Runner

SCGI Rails Runner is a complete implementation of the *Simple CGI* protocol for Ruby 
on Rails as specified by the http://python.ca/nas/scgi/protocol.txt specification.
SCGI is similar to FastCGI except that it is much simpler to implement and is
actively maintained by the original author.  The primary advantages of 
SCGI over the current FastCGI are:

* Completely pure Ruby yet still quite fast when compared with FastCGI.
* The core implementation (SCGI::Processor) is extensible for other frameworks.
* Systems other than Rails can use the library to implement their own versions.
* An extensive control mechanism to let you start, stop, restart, and reload even remotely.
* Cluster management using the scgi_cluster tool.
* Configuration file based so you can set options and start from command line easily.
* Runs on nearly everything with initial support for Windows.
* Restarts and stops are graceful, with redirects to a /busy.html 
  page for clients during the shutdown phase.
* You can set a throttle and max connections setting to reduce the load an
  application puts on your system.
* Works with lighttpd, Apache 1.3.x and Apache 2.0.x or later.  Precompiled
  mod_scgi for Apache on Win32.
* The base library has NO external dependencies as far as I know.

There's quite a few other features, but I tried to keep the complexity down while
still meeting the reasonable requests of the users.  If there's something more you
think I should add then please contact me at zedshaw AT zedshaw DOT com.


== Comparison With FastCGI

SCGI and FastCGI have similar goals:  To keep Ruby running between requests and process
the requests as fast as possible.  The difference is that SCGI is much simpler and easier
to implement so there's less chance to get it wrong.

Specifically, the SCGI Rails Runner (SRR) is written in pure Ruby so it doesn't leak memory,
runs everywhere, and is easy to install (no compilers needed).

One thing that SCGI doesn't support is using UNIX Domain sockets rather than TCP/IP sockets.
This isn't really needed, but it is handy in a shared hosting situation where you don't want
other connecting to your processes or if you have to request open ports.  Sorry, no UNIX
Domain sockets in SCGI.


== Comparison With WEBrick

In theory WEBrick should be able to run just as fast as SRR.  They are both written in
pure Ruby.  They both do similar processing (although WEBrick's are a little more complicated).
They both return about the same amount of data.

In practice WEBrick in production mode runs much slower than SRR in production mode.

If you're doing development, I recommend using WEBrick for two reasons.  First,
WEBrick is easier to start and stop since you just use script/server.  Second,
on Mac OSX several people have said that SRR cannot run in development mode.  Note this
is probably *only* Mac OSX.  SRR runs just fine in development mode on Linux.


== Comparison With CGI

CGI is where every time a request comes in for rails the whole Ruby on Rails
framework is loaded.  This is very slow, but it's easy to install.

An alternative is to use the cgi2scgi program distributed with the SCGI source
available from http://www.mems-exchange.org/software/scgi/ along with the Apache
modules.  This program basically is a small little C program that runs quickly
as a CGI, but passes it's requests to your SRR backend.  It's not all that fast,
but if you're stuck with cgi-bin only access then this might be just the way to
go.  Since SCGI runs over TCP/IP you can even host your SRR on a totally different
machine with this.


= Install
 
Installing SRR is pretty easy.  There's two main ways you can do it: via gems 
or with a ruby setup script.


== Requirements

To use the SRR files you'll need a few other packages which you can easily 
install via RubyGems:

* cmdparse -- The version used is 2.0.0
* highline -- This is used for prompts and colors and general text UI.
* rails -- Yeah, if I need to tell you this then you are seriously hosed.

NOTE:  These requirements are really only for the included commands.  The
actual SCGI implementation in scgi.rb doesn't have any external dependencies.


== RubyGems

Simply run:

  > wget http://www.zedshaw.com/downloads/scgi_rails/scgi_rails-VERSION.gem
  > gem install scgi_rails-VERSION.gem

Replacing VERSION with the one you want.  Eventually I'll stop being lazy
and figure out how to get the gem into the official source.


== Ruby Setup Script

Another way to do it is to download the source and install directly.

  > wget http://www.zedshaw.com/downloads/scgi_rails/scgi_rails-VERSION.tar.bz2
  > tar -xjf scgi_rails-VERSION.tar.bz2
  > cd scgi_rails-VERSION
  > sudo ruby setup.rb

These instructions are for POSIX systems like Linux or BSD of course.  If
you're on windows then you'll be better off using the RubyGem install method
(please correct me if I'm wrong on this).


= Configuring

Once you've installed SRR and--all the dependencies--you can get started setting
it up.  The big difference between FastCGI, previous versions of SRR, and the
new version of SRR is that you first configure your setup.  After you configure
your setup you can simply start/stop it without any more bother.

To make the configuration easy the scgi_ctrl (and later, the scgi_cluster) 
command will configure things for you with all options set to reasonable
defaults.  What this command does is write a *config/scgi.yaml* file
with all the options you need.

 > cd myrailsapp
 > scgi_ctrl config
 What password do you want? mypassiscool

This configures your SCGI setup to have the password
"mypassiscool" which you'll use later when you control your
rails deployment. 

Once you've configured SRR you can start your first SRR by simply doing:

 > scgi_ctrl start

If you want to get more advanced you can simply run:

 > scgi_ctrl help config

This will give you all of the possible options available.


== The scgi.yaml Contents

You don't *really* need to know this, but it might help in
debugging situations.  For example, if your site seems to be a lot 
slower than it should be then check the config/scgi.yaml file to
see if :throttle: is set.

The scgi.yaml file contains a YAML dump of an option map with these settings:

* :control_url: -- The DRb URL used to control your deployment.  (same host with port == SCGI-1000, so druby://127.0.0.1:8999)
* :env: -- Environment setting for RAILS_ENV. (production)
* :host: -- Host to bind.  (127.0.0.1, other might be *bad* for security)
* :password: -- A crypt image of your password.
* :port: -- Port to bind SCGI to.  (9999)
* :config: -- The config file.  Kind of redundant, but used by the control tools. (config/scgi.yaml)
* :throttle: Optional connections/second throttle setting. (unlimited)
* :logfile: Logfile to write log messages. (log/scgi.log)
* :maxconns: -- Optional maximum simultaneous connections before a user is redirected to /busy.html
* :disable_signals -- Turns off POSIX signal control (useful on Win32)
* :disable_drb -- Turns off DRb control, which means no spiffy scgi_ctrl or scgi_cluster.

The :maxconns: and :throttle: options will only be in the file if you set them.  A very nice
thing about SRR is that you can set these, then reconfigure the processors and they'll pick
up the new values without restarting.  This is very handy if you have a nasty processor which
is eating your computer.


= Running (UNIX)

Once you've configured SRR you can run it by just doing:

 > scgi_ctrl start

Which of course starts it up on the two ports you configured.  By default
this is 9999 for SCGI and 8999 for DRb.

All SCGI related activity (including any weird errors) will show up in
logs/scgi.log.  You should look at this to see if you get a line like:

 [INF][15978] Running in production mode on 127.0.0.1:9999

Which simply means an INFo message from PID 15978 that it's listening on port 9999 
in production mode.


= Running (Win32)

I haven't completely tested this all on Win32 yet.  There are two main things about
running under Win32.  First that you *must* use the -S option to scgi_ctrl config.
This turns off POSIX signals since Win32 doesn't support them.  Second that you
run the scgi_service script manually with:

 > scgi_service

This is simply because Ruby has really really really really bad support for starting
and stopping processes under Windows.  I'm currently looking at ways to either get
Apache to start the scgi_service script dynamically or to create a service that will
do it.


= Control

The control mechanism for SRR is a DRb based set of simple APIs
you can call.  DRb is basically a Remote Procedure Call system
for Ruby that's dead easy to use.  The problem with DRb is that
it has lousy security (which I cover in the Security section below).

Before going into the normal mode of control, you should know that
you can also use POSIX signals to do just about everything:

* TERM -- Forced shutdown.
* INT -- Graceful shutdown.
* HUP -- Graceful restart (no forced).
* USR1 -- Soft reconfigure (reloads config file).
* USR2 -- Dumps status info to the logs.  Super ugly.

Refer to the scgi_ctrl help for more accurate information, but the commands are:

* config -- Configure the SCGI server.  This you've already seen
  and it just generates a new config/scgi.yaml file.  You can actually
  do this while SRR is running and then use reconfig to reload some options.
* monitor -- Monitor the application.  This just dumps status all the time.
* reconfig -- Reconfigure the SCGI servers with a new config.  This doesn't
  load all options, but it will reset :maxconns: and :throttle:.
* restart -- Restart the application.  This is a graceful shutdown followed by
  a new exec of the same script.
* start -- Start the application.  Simply execs the scgi_service script with
  the right config/scgi.yaml file.
* status -- Get status.  Prints out a status from the SRR service.
* stop -- Stop the application.  Does a graceful shutdown (can be forced).

The commands are pretty self explanatory (I hope).  When you run a command it
will read the DRb :control_url: setting out of the config/scgi.yaml file and
try to connect to that URL.  You can override this with the -u parameter
before the command like this:

 > scgi_ctrl -u druby://someotherhost.com:17000 status

The other thing you'll notice is that it asks you for a password.  This is
the password that you configured earlier so you should remember it.  You can
of course just use signals to shutdown if you forget.


= Clusters

The new SRR comes with a fairly complete "cluster" management command called
*scgi_cluster*.  It's basically the exact same as *scgi_ctrl* except it 
configures and works on any number of processors at once.  With *scgi_cluster*
you can quickly configure a number of SRR processors and manage them.


== Cluster Configuration

Configuring is the same, except that there's a new -c parameter to configure
the number of children you want to manage.  What this does is takes your
initial parameters as the base, and then extends them for each child.

For example, if you wanted 5 children all starting at port 9999 (DRb ort 8999)
then you'd just use the defaults:

  > scgi_cluster config -c 5

This will write out 5 config files--one for each processor.  The ports will
start at 9999 and 8999 and increment by one from there.  So you'd have
9999, 10000, 10001, 10002, 10003.

The final difference is that scgi_cluster creates another config/scgi-cluster.yaml
file which tells it about your cluster.


== Running a Cluster (UNIX)

Running your cluster is pretty much the same as with *scgi_ctrl* after you've
configured things.

 > scgi_cluster start

This will start up your configured children and create a config/scgi-children.yaml
file for tracking the processes that get started.  You should also see log
messages in log/scgi.log like this:

 [INF][16129] Running in production mode on 127.0.0.1:9999
 [INF][16131] Running in production mode on 127.0.0.1:10001
 [INF][16130] Running in production mode on 127.0.0.1:10000

Which are the same but one for each processor.


== Running a Cluster (WINDOWS)

Running under Win32 does not work since Process.fork does not work.  Hopefully
I can crack this nut soon.


== Configuring Lighttpd Clusters

I figured I'd toss in the configuration I used for Lighttpd to get a cluster going:

 server.error-handler-404 = "/dispatch.scgi"
 scgi.server = ( "dispatch.scgi" =>
        (
        "server1" =>
                ( "host" => "127.0.0.1",
                "port" => 9999,
                "check-local" => "disable"),                   
                                                               
        "server2" =>
                ( "host" => "127.0.0.1",
                "port" => 10000,
               "check-local" => "disable"),

        "server3" =>
                ( "host" => "127.0.0.1",
                "port" => 10001,
               "check-local" => "disable")
        )
 )

That's for three processors.  It works pretty well although
lighttpd seems to favor the first processor rather than
do a fair load balancing.

== Cluster Control

Controlling the cluster is exactly the same except that *scgi_cluster*
runs against all the children listed in config/scgi-children.yaml and
makes them do things for you.  All of the commands are the same, except
the status and monitor commands.  Since there's so many children running
the verbose status just doesn't work.  Instead, you can request verbose,
but you get an abbreviated status by default that looks like this:

 16131   0/12    0       NA      false   1.88
 16129   0/12    0       NA      false   1.96
 16130   0/12    0       NA      false   1.88

This is the PID, current connections/max connections, total requests served,
throttle setting, whether the process is in shutdown, and the total user+sys time used.

It will also turn some of the display items red if they are out of control.


= Security

Alright, listen up.  I'm not gonna have people trying to take me to court because
they think I didn't tell them about security problems.  Here are the main attack
vectors you should be aware of when running this:

* POSIX signals are bad if you're in a shared hosting setup that configures all
  processes to run as a common user like *nobody*.  If your provider does this
  then you should give *scgi_ctrl* the -S option to turn them off.
* DRb is not *encrypted*.  I repeat, DRB is *not* encrypted.  This is fine if
  you're on a controlled machine and do everything on localhost since if anyone
  breaks into your machine you have a lot more to worry about than DRb leaking passwords.
  But, again, if you're on a shared hosting system then there's a good chance someone
  can packet sniff the localhost device and read your password.  I'm looking at an SSL
  configuration option for DRb in the near future.
* The config files under POSIX systems are created with your default umode settings.
  No changes are made since most of the permission mode stuff doesn't work on Win32.
  Also, you should configure your umode when you're on shared hosting so that nobody
  else can read your files anyway.  This means that if you're not careful someone
  can potentially read or alter your configuration and make your program do bad things.
* I tried to remove all possible DRb methods except the allowed ones (DRb by default
  only has blacklist access exclusion), but it might be possible for someone to access
  the DRb port and find a way to run something remotely.  The password will really
  only protect against people from running the control methods.

That's the gist of the security situation.  Feel free to send me more security warnings
and if you have ideas to fix these problems then please let me know.

Incidentally, don't think that because I mention these here that FastCGI doesn't have
these same problems.  If you're running FastCGI processes in a shared hosting environment
then you should check for these same problems.

